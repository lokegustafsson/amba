Fuzzing är ett användbart automatiskt verktyg för att testa program efter
ofta svårupptäckta problem som minnesbuggar, krascher, etc. tack vare dess
enkelhet i att konfigurera verktyget mot godtyckliga program.  

Grundprincipen i fuzzing är att attackera en större mängd av möjlig indata genom
att generera oväntad, godtycklig eller felaktig data. Denna typ av genererad
indata resulterar ofta i syntaktiskt eller semantiskt felaktig indata som inte
kan hanteras av målprogrammet. Således finns det anledning för
utvecklingspotential, något som lett till bland annat mutation-based fuzzing och
generaton-based fuzzing. Mutation-based fuzzing muterar känd giltig indata,
t.ex. om strängen "fuzz" är giltig indata kan detta muteras till "fuzzZZZZZ". Om
en användare exempelvis vill fuzztesta bildhanteringsbiblioteket libjpeg skulle
detta innebära att skicka giltiga jpeg-bilder till fuzzern för att användas som
seeds, ett värde som används i en pseudoslumptalsgenerator för att generera ett
pseudoslumptal, och sedan modifiera dessa. Detta skiljer sig från
Generation-based fuzzing som genererar indata givet en modell för domänen -- en
fördel i jämförelse med mutation-based fuzzing som kräver känd kvalitativ
indata~\cite{fuzzing}. 

\subsection{Problem med fuzzing}
Ett problem är insikt om den underliggande kodstrukturen. En
viktig egenskap hos fuzzers som används för att beskriva dess effektivitet är
code coverage -- fuzzerns förmåga att traversera över samtliga kanter och noder i programmets
kontrollflödesgraf. Black-box fuzzing är ett exempel på en fuzzer
som saknar vetskap om den underliggande kodstrukturen och genererar
endast slumpmässig indata, något som leder till ytlig testning av målprogrammet.
I kontrast till black-box fuzzing finns det andra fuzzers, till exempel gray-box
fuzzern AFL~\cite{aflplusplus} som tillämpar binärinstrumentering, en teknik för att observera
eller manipulera en binär vilket görs genom att modifiera källkoden i binären.
Genom binärinstrumentering fås information om underliggande basic blocks som
delger övergången till nästa basic block. Detta används sedan av AFL för att ge
feedback till fuzzern som minns code coverage för en viss indata och repeterar
denna process för att maximera code coverage med ny indata och därmed öka
testytan~\cite{challenges_fuzzing}.

Fuzzers kräver ofta protokoll- eller domänkännedom för att kunna generera
indata. Detta blir problem för komplexa kodbaser eller bibliotek som saknar
trivial eller uppenbar indata och leder därmed till lägre code coverage.

\subsection{Symbolisk fuzzing}
Symbolisk fuzzing, eller concolic testing, är en white-box fuzzer som nyttjar
symbolisk exekvering för att nå maximal code coverage. Skiljt från gray-box
fuzzers som AFL, möjliggör symbolisk exekvering att fuzzern alltid väljer en
branch som inte tidigare tagits och således ökar code
coverage~\cite{challenges_fuzzing}.  


% vad är viktigt att veta om symbolisk fuzzing? hur används symbolisk
% exekvering? 
% hur används symbolisk exekvering?


