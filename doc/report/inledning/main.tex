En stor mängd organisationer har utsats för utpressningsprogram (jfr eng.
\emph{ransomware}) minst en gång de senaste 24 månaderna~\cite{cyberreason2021,
cyberreason2022}. Några av de direkta följderna av att en lyckad attack är: höga
kostnader för organisationen; stoppad produktion; konsekvenser från reglerare;
och skadat anseende~\cite{cyberreason2021, cyberreason2022}. Dessutom leder
de höga kostnaderna till bland annat uppsägningar av anställda för att kunna
kompensera~\cite{cyberreason2021, cyberreason2022}. Till exempel påverkades
Irlands offentliga sjuknussystem kraftigt när utpressningsprogram tog över en
stor del av deras digitala infrastruktur~\cite{hse_report, gallagher2023}. I
många fall är människan den svaga länken i cyberattacker men angripare och
skadeprogram (jfr eng. \emph{malware}) utnyttjar också olika sårbarheter i
programvaror.

Vanliga fel i program som utnyttjas av angripare och skadeprogram är
minnesårbarheter. Det som gör minnessårbarheter allvarligare till skillnad från
andra fel som logikfel är att minnessårbarheter kan utnyttjas för att påverka
ett programs kontrolflöde (jfr eng. \emph{control flow}) och alltså dess
beteende. Minnesårbarheter tillåter minnesaccess utanför en viss minnesregion.
Det kan vara alvarligt om en angripare kan läsa delar av minnet som inte ska
vara läsbart men det mest allvarliga är skrivaccess utanför minnesgränser. En
angripare kan använda det för att t.ex. exekvera godtyckliga kommandon på
datorn som kör programmet~\cite{computer_security_cs161}.

Det är möjligt att undvika olika minnessårbarheter som
programutvecklare genom försiktighet men för att undvika 100\% av
minnessårbarheter krävs användning av minnessäkra programspråk (jfr eng.
\emph{memory-safe language}).
Minnessäkra programspråk tilltar en kombination av körtids- (jfr eng.
\emph{runtime}) och kompileringstidskontroller (jfr eng. \emph{compile time
checks}) för att undvika minnessårbarheter. Däremot finns det än idag många
skäl för att fortsätta använda minnesosäkra programspråk som
C, såsom prestandaskäl~\cite{computer_security_cs161}.

Genom att analysera program kan säkerhetsforskare och utvecklare upptäcka
och åtgärda sårbarheter innan en angripare. Programanalys går ut på att
analysera programegenskaper. Det finns många olika metoder för programanalys
och kan utföras olika på nivåer: på källkoden eller på binären. Genom att
bektrakta den kompilerade binären kan de verkliga egenskaperna av programmet
analyseras. Binäranalys tar hänsyn till fel som introduceras i
kompileringssteget och undviker även problem med det semantiska gapet mellan
ett högnivåspråk och den faktiska maskinkod och data som blir produkten efter
kompilering. Genom binäranalys undersöker man vad ett program faktiskt gör
istället för vad man tror att den gör. I sammanhanget av skadeprogramsanalys
(jfr eng. \emph{malware analysis}) och \emph{reverse engeneering} finns inget
annat val än binäranalys eftersom källkoden inte är
tillgänglig~\cite{andriesse2018}.

En metod för binäranalys är \emph{fuzzing} som går ut på att mata olika indata
till ett program och betrakta fel som uppstår. Målet med \emph{fuzzing} är att
uppnå en hög täckning (jfr eng. \emph{coverage}) av programmet som beror
på indatan. Alltså att ta alla möjliga vägar genom kontrollflödet som är
möjliga att nå genom att variera indatan. Däremot är det ett svårt problem att
generera indata som uppnår en hög täckning som även är effektivtast, speciellt
när indatan kan ha ett högt antal olika värden. Symbolisk exekvering är ett
exekveringssätt som syftar till att lösa detta problem. Det är en ett sätt att
exekvera ett program abstrakt där en exekvering betraktar alla möjliga indata
som delar en viss exekveringsväg genom kontrollflödet. Symbolisk fuzzing
använder symbolisk exekvering för att generera olika indata till \emph{fuzzing}
processen som effektivast uppnår den högsta täckning som kan uppnås genom att
variera indatan.

% why visualize the symbolic fuzzing process is something we need?

% s2e ett av många alternativ, finns några andra exempel på symbolic execution engines

