En metod för dynamisk binäranalys är symbolisk exekvering. Eftersom exekveringen är symbolisk är
det möjligt att utforska alla möjliga exekveringsvägar i programmet, även de som inte är möjliga
med konkreta inputs. Både \stoe{} och SymQEMU är kraftfulla verktyg för att analysera binära program
med symbolisk exekvering.

SymQEMU är byggt som en förlängning av QEMU, och använder en kombination av dynamisk binär
översättning och symbolisk exekvering för att analysera binära program som körs inuti emulatorn.
SymQEMU utför kompileringsbaserad symbolisk exekvering, där den mellanliggande representationen först blir modifierad
innan den översätts till värdarkitekturen, och är därför arkitekturoberoende utan att påverka prestandan~\cite{symqemu}.

\stoe{} är ett modulärt bibliotek som ger virtuella maskiner symbolisk exekvering. \stoe{} erbjuder
redskap för att fokusera utforskningen på delkomponenter av systemet och gör det även
möjligt för användare att sätta in kod i målsystemet vid specifika punkter under
exekvering. Det gör att användare kan anpassa analysprocessen efter sina behov~\cite{s2e}.
\stoe{} kan analysera kod för de flesta processorarkitekturer men betalar för det med ökad
komplexitet och prestanda~\cite{symqemu}.

Ett annat verktyg för att identifiera buggar och sårbarheter med hjälp av dynamisk symbolisk
exekvering är SAGE (Scalable Automated Guided Execution).
SAGE var det första verktyget som utförde dynamisk symbolisk exekvering på x86-binärnivå och använder flera
avgörande optimeringar för att hantera stora exekveringsspår (jfr.\ eng. execution traces).
För att skala upp till stora exekveringsspår använder SAGE flera tekniker för att förbättra hastigheten och
minnesanvändningen för constraint generering, exempelvis så kartläggs ekvivalenta symboliska uttryck till samma
objekt och constraints som redan är tillagda hoppas över~\cite{sage}.

Binäranalysverktyget angr stödjer både statiska och dynamiska analyser med hjälp
av symbolisk exekvering. angr är ett ramverk för binäranalys och har stöd för
disassemblering till pseudo-C-kod och implementerar många analyser användaren
kan utföra. angr bygger på en symbolisk emulator skriven i Python och analyser
utförs genom Python-skript som interagerar med angrs API.\@ angr har använts för
att framställa skript som kan utföra \emph{reverse engineering},
sårbarhetssökning och fungera som exploateringsverktyg~\cite{angr_docs}.
Tävlingen Cyber Grand Challenge organiserades 2016 av DARPA. I tävlingen skulle
lag skriva helautomatiska system som hittar, korrigerar och angriper sårbarheter
i CTF-liknande uppgifter. Det vinnande systemet, Mayhem, använde angr som
symbolisk exekveringsmotor.

För att accelerera den symboliska exekveringen kan angr användas i kombination
med Unicorn CPU-emulatorn, ett lättviktigt ramverk för emulering som stödjer
många arkitekturer och baseras på QEMU~\cite{UnicornEngine}. Detta är möjligt
med hjälp av komponenten \emph{angr.engines.unicorn}. Genom att använda
komponenten kan man exekvera med konkreta input när det är möjligt och
fördelaktigt men understött av symbolisk exekvering då flera exekveringsvägar
behöver utforskas eller då programmets beteende inte är
deterministiskt~\cite{angr_uni}.

