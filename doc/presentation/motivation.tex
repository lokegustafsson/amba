\begin{frame}
	% Program analysis is vital for verifying program properties. This
	% requires, as you might imagine, examining many paths a program may take,
	% all of them if you want the best results.

    \textbf{Program analysis}
	\vspace{3.0mm}
	\begin{figure}
		\includegraphics[height=5cm]{assets/DALLÂ·E 2023-05-21 23.06.07 - magnifying glass zooming in on a hello world program written in C.png}
		\footnote{\tiny Generated by DALL$\cdot$E}
	\end{figure}
\end{frame}

\begin{frame}
	\vspace{3.0mm}
    \textbf{Program analysis}
    \begin{center}
			\tiny{
                \begin{tikzpicture}[
                    roundnode/.style={circle, minimum size=7mm},
                    question/.style={diamond, draw, fill=lightgray!80},
                    squarednode/.style={draw, fill=lightgray!80, minimum height=0.3cm},
                    arrow/.style={draw, -latex'}
                    ]

					\node [squarednode] (A)                       {inp $\leftarrow$ input()};
					\node [question] (B)       [below=of A]  {inp = 93784739};
                    \node [squarednode] (C)     [right =of B] {...};
                    \node [squarednode] (E)     [below=of C] {x $\leftarrow$ 1 / (inp-93784739)};
                    \node [roundnode, draw=red!60, fill=red!5] (F)     [below=of E] {exitcode 1};
                    \node [squarednode]    (D)    [below=of B]  {...};
                    \node [roundnode, draw=green!60, fill=green!5]    (G)    [below=of D]  {exitcode 0};

					\draw [arrow] (A) -- (B);
                    \draw [arrow] (B.east) -- (C) node [midway, above] (yesCond) {yes};
					\draw [arrow] (B.south) -- (D) node [midway, left] (noCond) {no};
					\draw [arrow] (C) -- (E);
					\draw [arrow] (D) -- (G);
					\draw [arrow] (E) -- (F);

				\end{tikzpicture}
			}
    \end{center}
\end{frame}

\begin{frame}
	\vspace{3.0mm}
    \textbf{Program analysis}
    \begin{center}
			\tiny{
                \begin{tikzpicture}[
                    roundnode/.style={circle, minimum size=7mm},
                    question/.style={diamond, draw, fill=lightgray!80},
                    squarednode/.style={draw, fill=lightgray!80, minimum height=0.3cm},
                    arrow/.style={draw, -latex'}
                    ]

					\node [squarednode] (A)                  {inp $\leftarrow$ input()};
					\node [question] (B)       [below=of A]  {inp = 93784739};
                    \node [squarednode] (C)     [right =of B] {...};
                    \node [squarednode] (E)     [below=of C] {x $\leftarrow$ 1 / (inp-93784739)};
                    \node [roundnode, draw=red!60, fill=red!5] (F)     [below=of E] {exitcode 1};
                    \node [squarednode]    (D)    [below=of B]  {...};
                    \node [roundnode, draw=green!60, fill=green!5, very thick]    (G)    [below=of D]  {exitcode 0};

					\draw [arrow] (A) -- (B);
                    \draw [arrow] (B.east) -- (C) node [midway, above] (yesCond) {yes};
                    \draw [arrow] (B.south) -- (D) node [midway, left, blue] (noCond) {\textbf{no}};
					\draw [arrow] (C) -- (E);
					\draw [arrow] (D) -- (G);
					\draw [arrow] (E) -- (F);

				\end{tikzpicture}
			}
    \end{center}
\end{frame}


\begin{frame}
	\vspace{3.0mm}
    \textbf{Program analysis}
    \begin{center}
			\tiny{
                \begin{tikzpicture}[
                    roundnode/.style={circle, minimum size=7mm},
                    question/.style={diamond, draw, fill=lightgray!80},
                    squarednode/.style={draw, fill=lightgray!80, minimum height=0.3cm},
                    arrow/.style={draw, -latex'}
                    ]

					\node [squarednode] (A)                       {inp $\leftarrow$ input()};
					\node [question] (B)       [below=of A]  {inp = 93784739};
                    \node [squarednode] (C)     [right =of B] {...};
                    \node [squarednode] (E)     [below=of C] {x $\leftarrow$ 1 / (inp-93784739)};
                    \node [roundnode, draw=red!60, fill=red!5, very thick] (F)     [below=of E] {exitcode 1};
                    \node [squarednode]    (D)    [below=of B]  {...};
                    \node [roundnode, draw=green!60, fill=green!5]    (G)    [below=of D]  {exitcode 0};

					\draw [arrow] (A) -- (B);
                    \draw [arrow] (B.east) -- (C) node [midway, above, blue] (yesCond) {\textbf{yes}};
					\draw [arrow] (B.south) -- (D) node [midway, left] (noCond) {no};
					\draw [arrow] (C) -- (E);
					\draw [arrow] (D) -- (G);
					\draw [arrow] (E) -- (F);

				\end{tikzpicture}
			}
    \end{center}
\end{frame}

\begin{frame}
	% Binary analysis is program analysis on the binary and is in many cases more
	% useful then program analysis on the source code. In some cases you don't
	% have a choice, like malware analysis where there is no source code, and in
	% other cases, because it shows the true behaviour of the program, after
	% potential compiler bugs introduced and other semantic effects applied.
	% Finally, binary analysis is a more general method for many software
	% stacks, in contrast to language specific, source level analysis tools.

	\textbf{Why binary analysis?}
    \vspace{1.8mm}
	\begin{itemize}
		\item Missing source code
		\item Compiler introduced bugs
		\item Semantic gap between source code and binary
		\item Doesn't depend on source language
	\end{itemize}
\end{frame}

